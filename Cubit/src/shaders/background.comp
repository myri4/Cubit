#pragma shader_stage(compute)

layout(local_size_x = 4, local_size_y = 4) in;
layout(binding = 0, rgba32f) restrict writeonly uniform image2D o_Image;

layout (push_constant) uniform Uniforms
{
    // Settings
    float time;
    float zoom;
    vec2 cameraPos;
};


#define iterations 15
#define formuparam 0.53

#define volsteps 20
#define stepsize 0.1

#define tile   0.850
#define speed  0.01 

#define brightness1 0.0015
#define darkmatter 0.300
#define distfading 0.730

void main() 
{ 
	vec2 imgSize = vec2(imageSize(o_Image));
	ivec2 invocID = ivec2(gl_GlobalInvocationID);  
	
	vec2 uv = vec2(float(invocID.x) / imgSize.x, float(invocID.y) / imgSize.y);


    uv.y*=imgSize.y/imgSize.x;
	vec3 dir=vec3(uv,1.);
	float itime= time*speed+.25;

	vec3 from=vec3(cameraPos * 0.0001f + itime, 0.5);
	
	//volumetric rendering
	float s=0.1,fade=1.;
	vec3 v=vec3(0.);
	for (int r=0; r<volsteps; r++) {
		vec3 p=from+s*dir*.5;
		p = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold
		float pa,a=pa=0.;
		for (int i=0; i<iterations; i++) { 
			p=abs(p)/dot(p,p)-formuparam; // the magic formula
			a+=abs(length(p)-pa); // absolute sum of average change
			pa=length(p);
		}
		float dm=max(0.,darkmatter-a*a*.001); //dark matter
		a*=a*a; // add contrast
		if (r>6) fade*=1.-dm; // dark matter, don't render near
		//v+=vec3(dm,dm*.5,0.);
		v+=fade;
		v+=vec3(s,s*s,s*s*s*s)*a*brightness1*fade; // coloring based on distance
		fade *= distfading; // distance fading
		s += stepsize;
	}

	imageStore(o_Image, invocID, vec4(v*.01, 1.f));
}